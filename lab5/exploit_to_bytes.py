import sys
import re
import math


def main():
    required = 152
    pads_per_line = 4

    if len(sys.argv) >= 2:
        required = int(sys.argv[1])

    if len(sys.argv) >= 3:
        pads_per_line = int(sys.argv[2])

    with open('exploit.lst', 'r') as file:
        lines = file.readlines()

    encoded_instructions = []
    instr_source = []

    for line in lines:
        cont = line.strip().split(' ')


        if len(cont) < 3 or cont[2] == '':
            continue

        if cont[1] == '00000090':
            continue

        instr_source.append ( re.sub(';.*', '', ' '.join(cont[3:]).strip()) )

        #print('{}: {}'.format(cont[0], cont[2]))
        encoded_instructions.append(cont[2])


    # break into bytes
    instr_byte_grps = []
    total_bytes = 0
    for inst in encoded_instructions:
        curinst = []
        # split the string into pairs
        curlen = len(inst)
        i=0
        while i < curlen:
            t  = inst[i:min(i+2, curlen)]
            if len(t) == 2:
                curinst.append( t )
                total_bytes += 1

            i = i+2

        instr_byte_grps.append(curinst)


    # get the required noops to pad
    noop_count = required-total_bytes
    # each line has max pad_per_line padding bytes
    pads_left = noop_count
    for _ in range(math.ceil(noop_count/pads_per_line)):
        noop_padding = [ '90' ] * min(pads_per_line, pads_left)
        instr_source.insert(0, 'noop padding ({})'.format(min(pads_per_line, pads_left)))
        instr_byte_grps.insert(0, noop_padding)
        pads_left -= pads_per_line

    # just some control information
    print('//Init Size: {}, Req Size: {}, Padding: {}'.format(total_bytes,required, noop_count))

    # then convert to the comma lines
    for inst, src in zip(instr_byte_grps,instr_source):
        line = ''
        for byte in inst:
            line += '0x{},'.format(byte.upper())

        print('{:50s}// {}'.format(line, src))

    return 0

if __name__ == '__main__':
    sys.exit(main())